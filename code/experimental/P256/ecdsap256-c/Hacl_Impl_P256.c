/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: /home/nkulatov/new2/kremlin/kremlin/krml -fbuiltin-uint128 -fnocompound-literals -fc89-scope -fparentheses -fcurly-braces -funroll-loops 4 -warn-error +9 -add-include "kremlib.h" -add-include "FStar_UInt_8_16_32_64.h" /dist/minimal/testlib.c -skip-compilation -no-prefix Hacl.Impl.P256 -bundle Lib.* -bundle Spec.* -bundle C=C.Endianness -bundle Hacl.Hash.SHA2=Hacl.Hash.*,Spec.Hash.* -bundle Hacl.Impl.P256=Hacl.Impl.P256.Arithmetics,Hacl.Impl.P256.PointDouble,Hacl.Impl.P256.PointAdd,Hacl.Impl.P256,Hacl.Impl.P256.MontgomeryMultiplication,Hacl.Impl.P256.LowLevel,Hacl.Impl.LowLevel,Hacl.Impl.SolinasReduction,Hacl.Spec.P256.*,Hacl.Spec.Curve25519.*,Hacl.Impl.Curve25519.* -library C,FStar -drop LowStar,Spec,Prims,Lib,C.Loops.*,Hacl.Spec.P256.Lemmas,Hacl.Spec.P256,Hacl.Spec.ECDSA,Hacl.Spec.Ladder -add-include "c/Lib_PrintBuffer.h" -add-include "FStar_UInt_8_16_32_64.h" -tmpdir ecdsap256-c .output/prims.krml .output/FStar_Pervasives_Native.krml .output/FStar_Pervasives.krml .output/FStar_Squash.krml .output/FStar_Classical.krml .output/FStar_StrongExcludedMiddle.krml .output/FStar_FunctionalExtensionality.krml .output/FStar_List_Tot_Base.krml .output/FStar_List_Tot_Properties.krml .output/FStar_List_Tot.krml .output/FStar_Mul.krml .output/FStar_Math_Lib.krml .output/FStar_Math_Lemmas.krml .output/FStar_Seq_Base.krml .output/FStar_Seq_Properties.krml .output/FStar_Seq.krml .output/FStar_Set.krml .output/FStar_Preorder.krml .output/FStar_Ghost.krml .output/FStar_ErasedLogic.krml .output/FStar_PropositionalExtensionality.krml .output/FStar_PredicateExtensionality.krml .output/FStar_TSet.krml .output/FStar_Monotonic_Heap.krml .output/FStar_Heap.krml .output/FStar_Map.krml .output/FStar_Monotonic_Witnessed.krml .output/FStar_Monotonic_HyperHeap.krml .output/FStar_Monotonic_HyperStack.krml .output/FStar_HyperStack.krml .output/FStar_HyperStack_ST.krml .output/FStar_Calc.krml .output/FStar_BitVector.krml .output/FStar_UInt.krml .output/FStar_UInt32.krml .output/FStar_Universe.krml .output/FStar_GSet.krml .output/FStar_ModifiesGen.krml .output/FStar_Range.krml .output/FStar_Reflection_Types.krml .output/FStar_Tactics_Types.krml .output/FStar_Tactics_Result.krml .output/FStar_Tactics_Effect.krml .output/FStar_Tactics_Util.krml .output/FStar_Reflection_Data.krml .output/FStar_Reflection_Const.krml .output/FStar_Char.krml .output/FStar_Exn.krml .output/FStar_ST.krml .output/FStar_All.krml .output/FStar_List.krml .output/FStar_String.krml .output/FStar_Order.krml .output/FStar_Reflection_Basic.krml .output/FStar_Reflection_Derived.krml .output/FStar_Tactics_Builtins.krml .output/FStar_Reflection_Formula.krml .output/FStar_Reflection_Derived_Lemmas.krml .output/FStar_Reflection.krml .output/FStar_Tactics_Derived.krml .output/FStar_Tactics_Logic.krml .output/FStar_Tactics.krml .output/FStar_BigOps.krml .output/LowStar_Monotonic_Buffer.krml .output/LowStar_Buffer.krml .output/LowStar_BufferOps.krml .output/Spec_Loops.krml .output/FStar_UInt64.krml .output/C_Loops.krml .output/FStar_Int.krml .output/FStar_Int64.krml .output/FStar_Int63.krml .output/FStar_Int32.krml .output/FStar_Int16.krml .output/FStar_Int8.krml .output/FStar_UInt63.krml .output/FStar_UInt16.krml .output/FStar_UInt8.krml .output/FStar_Int_Cast.krml .output/FStar_UInt128.krml .output/FStar_Int_Cast_Full.krml .output/FStar_Int128.krml .output/Lib_IntTypes.krml .output/Lib_Loops.krml .output/Lib_LoopCombinators.krml .output/Lib_RawIntTypes.krml .output/Lib_Sequence.krml .output/Lib_ByteSequence.krml .output/LowStar_ImmutableBuffer.krml .output/Lib_Buffer.krml .output/FStar_HyperStack_All.krml .output/Hacl_Spec_ECDSAP256_Definition.krml .output/Spec_Hash_Definitions.krml .output/Spec_Hash_Lemmas0.krml .output/Spec_Hash_PadFinish.krml .output/Spec_SHA1.krml .output/Spec_MD5.krml .output/Spec_SHA2_Constants.krml .output/Spec_SHA2.krml .output/Spec_Hash.krml .output/Hacl_Spec_P256_Definitions.krml .output/FStar_Reflection_Arith.krml .output/FStar_Tactics_Canon.krml .output/Hacl_Spec_P256_Lemmas.krml .output/Hacl_Spec_P256.krml .output/Hacl_Spec_ECDSA.krml .output/Hacl_Impl_LowLevel.krml .output/Hacl_Impl_ECDSA_MontgomeryMultiplication.krml .output/FStar_Kremlin_Endianness.krml .output/C_Endianness.krml .output/C.krml .output/Lib_ByteBuffer.krml .output/Hacl_Impl_ECDSA_P256SHA256_Common.krml .output/Hacl_Spec_P256_MontgomeryMultiplication.krml .output/Hacl_Impl_P256_LowLevel.krml .output/Hacl_Spec_P256_SolinasReduction.krml .output/Hacl_Impl_SolinasReduction.krml .output/Spec_Hash_Incremental.krml .output/Spec_Hash_Lemmas.krml .output/Hacl_Hash_Lemmas.krml .output/LowStar_Modifies.krml .output/Hacl_Hash_Definitions.krml .output/Hacl_Hash_PadFinish.krml .output/Hacl_Hash_MD.krml .output/Hacl_Math.krml .output/Hacl_Impl_P256_MontgomeryMultiplication.krml .output/Hacl_Impl_P256_Arithmetics.krml .output/Hacl_Spec_P256_MontgomeryMultiplication_PointDouble.krml .output/Hacl_Spec_P256_MontgomeryMultiplication_PointAdd.krml .output/Hacl_Spec_P256_Ladder.krml .output/Hacl_Impl_ECDSA_MM_Exponent.krml .output/Hacl_Spec_P256_Normalisation.krml .output/Hacl_Impl_P256_PointDouble.krml .output/Hacl_Impl_P256_PointAdd.krml .output/Hacl_Impl_P256.krml .output/Hacl_Hash_Core_SHA2_Constants.krml .output/Hacl_Hash_Core_SHA2.krml .output/Hacl_Hash_SHA2.krml .output/Hacl_Impl_ECDSA_P256SHA256_Signature.krml
  F* version: 0fd6ae12
  KreMLin version: 27ce15c8
 */

#include "Hacl_Impl_P256.h"

static uint64_t
Hacl_Impl_LowLevel_add_carry(uint64_t cin, uint64_t x, uint64_t y, uint64_t *result1)
{
  uint64_t res1 = x + cin;
  uint64_t c;
  if (res1 < cin)
  {
    c = (uint64_t)1U;
  }
  else
  {
    c = (uint64_t)0U;
  }
  {
    uint64_t res = res1 + y;
    uint64_t c1;
    if (res < res1)
    {
      c1 = c + (uint64_t)1U;
    }
    else
    {
      c1 = c;
    }
    result1[0U] = res;
    return c1;
  }
}

uint64_t Hacl_Impl_LowLevel_add4(uint64_t *x, uint64_t *y, uint64_t *result)
{
  uint64_t *r0 = result;
  uint64_t *r1 = result + (uint32_t)1U;
  uint64_t *r2 = result + (uint32_t)2U;
  uint64_t *r3 = result + (uint32_t)3U;
  uint64_t cc0 = Hacl_Impl_LowLevel_add_carry((uint64_t)0U, x[0U], y[0U], r0);
  uint64_t cc1 = Hacl_Impl_LowLevel_add_carry(cc0, x[1U], y[1U], r1);
  uint64_t cc2 = Hacl_Impl_LowLevel_add_carry(cc1, x[2U], y[2U], r2);
  uint64_t cc3 = Hacl_Impl_LowLevel_add_carry(cc2, x[3U], y[3U], r3);
  return cc3;
}

static uint64_t
Hacl_Impl_LowLevel_add4_with_carry(uint64_t c, uint64_t *x, uint64_t *y, uint64_t *result)
{
  uint64_t *r0 = result;
  uint64_t *r1 = result + (uint32_t)1U;
  uint64_t *r2 = result + (uint32_t)2U;
  uint64_t *r3 = result + (uint32_t)3U;
  uint64_t cc = Hacl_Impl_LowLevel_add_carry(c, x[0U], y[0U], r0);
  uint64_t cc1 = Hacl_Impl_LowLevel_add_carry(cc, x[1U], y[1U], r1);
  uint64_t cc2 = Hacl_Impl_LowLevel_add_carry(cc1, x[2U], y[2U], r2);
  uint64_t cc3 = Hacl_Impl_LowLevel_add_carry(cc2, x[3U], y[3U], r3);
  return cc3;
}

uint64_t Hacl_Impl_LowLevel_add8(uint64_t *x, uint64_t *y, uint64_t *result)
{
  uint64_t *a0 = x;
  uint64_t *a1 = x + (uint32_t)4U;
  uint64_t *b0 = y;
  uint64_t *b1 = y + (uint32_t)4U;
  uint64_t *c0 = result;
  uint64_t *c1 = result + (uint32_t)4U;
  uint64_t carry0 = Hacl_Impl_LowLevel_add4(a0, b0, c0);
  uint64_t carry1 = Hacl_Impl_LowLevel_add4_with_carry(carry0, a1, b1, c1);
  return carry1;
}

static uint64_t
Hacl_Impl_LowLevel_add4_variables(
  uint64_t *x,
  uint64_t cin,
  uint64_t y0,
  uint64_t y1,
  uint64_t y2,
  uint64_t y3,
  uint64_t *result
)
{
  uint64_t *r0 = result;
  uint64_t *r1 = result + (uint32_t)1U;
  uint64_t *r2 = result + (uint32_t)2U;
  uint64_t *r3 = result + (uint32_t)3U;
  uint64_t cc = Hacl_Impl_LowLevel_add_carry(cin, x[0U], y0, r0);
  uint64_t cc1 = Hacl_Impl_LowLevel_add_carry(cc, x[1U], y1, r1);
  uint64_t cc2 = Hacl_Impl_LowLevel_add_carry(cc1, x[2U], y2, r2);
  uint64_t cc3 = Hacl_Impl_LowLevel_add_carry(cc2, x[3U], y3, r3);
  return cc3;
}

uint64_t Hacl_Impl_LowLevel_sub_borrow(uint64_t cin, uint64_t x, uint64_t y, uint64_t *result1)
{
  uint64_t res = x - y - cin;
  uint64_t c;
  if (cin == (uint64_t)1U)
  {
    if (x <= y)
    {
      c = (uint64_t)1U;
    }
    else
    {
      c = (uint64_t)0U;
    }
  }
  else if (x < y)
  {
    c = (uint64_t)1U;
  }
  else
  {
    c = (uint64_t)0U;
  }
  result1[0U] = res;
  return c;
}

uint64_t Hacl_Impl_LowLevel_sub4_il(uint64_t *x, uint64_t *y, uint64_t *result)
{
  uint64_t *r0 = result;
  uint64_t *r1 = result + (uint32_t)1U;
  uint64_t *r2 = result + (uint32_t)2U;
  uint64_t *r3 = result + (uint32_t)3U;
  uint64_t cc = Hacl_Impl_LowLevel_sub_borrow((uint64_t)0U, x[0U], y[0U], r0);
  uint64_t cc1 = Hacl_Impl_LowLevel_sub_borrow(cc, x[1U], y[1U], r1);
  uint64_t cc2 = Hacl_Impl_LowLevel_sub_borrow(cc1, x[2U], y[2U], r2);
  uint64_t cc3 = Hacl_Impl_LowLevel_sub_borrow(cc2, x[3U], y[3U], r3);
  return cc3;
}

static uint64_t Hacl_Impl_LowLevel_sub4(uint64_t *x, uint64_t *y, uint64_t *result)
{
  uint64_t *r0 = result;
  uint64_t *r1 = result + (uint32_t)1U;
  uint64_t *r2 = result + (uint32_t)2U;
  uint64_t *r3 = result + (uint32_t)3U;
  uint64_t cc = Hacl_Impl_LowLevel_sub_borrow((uint64_t)0U, x[0U], y[0U], r0);
  uint64_t cc1 = Hacl_Impl_LowLevel_sub_borrow(cc, x[1U], y[1U], r1);
  uint64_t cc2 = Hacl_Impl_LowLevel_sub_borrow(cc1, x[2U], y[2U], r2);
  uint64_t cc3 = Hacl_Impl_LowLevel_sub_borrow(cc2, x[3U], y[3U], r3);
  return cc3;
}

void Hacl_Impl_LowLevel_mul64(uint64_t x, uint64_t y, uint64_t *result, uint64_t *temp)
{
  uint128_t res = (uint128_t)x * y;
  uint64_t l0 = (uint64_t)res;
  uint64_t h0 = (uint64_t)(res >> (uint32_t)64U);
  result[0U] = l0;
  temp[0U] = h0;
}

static void
Hacl_Impl_LowLevel_mult64_0(uint64_t *x, uint64_t u, uint64_t *result, uint64_t *temp)
{
  uint64_t f0 = x[0U];
  Hacl_Impl_LowLevel_mul64(f0, u, result, temp);
}

static void
Hacl_Impl_LowLevel_mult64_0il(uint64_t *x, uint64_t u, uint64_t *result, uint64_t *temp)
{
  uint64_t f0 = x[0U];
  Hacl_Impl_LowLevel_mul64(f0, u, result, temp);
}

static uint64_t
Hacl_Impl_LowLevel_mult64_c(
  uint64_t x,
  uint64_t u,
  uint64_t cin,
  uint64_t *result,
  uint64_t *temp
)
{
  uint64_t h = temp[0U];
  uint64_t l;
  Hacl_Impl_LowLevel_mul64(x, u, result, temp);
  l = result[0U];
  return Hacl_Impl_LowLevel_add_carry(cin, l, h, result);
}

static uint64_t Hacl_Impl_LowLevel_mul1_il(uint64_t *f, uint64_t u, uint64_t *result)
{
  uint64_t temp = (uint64_t)0U;
  uint64_t f1 = f[1U];
  uint64_t f2 = f[2U];
  uint64_t f3 = f[3U];
  uint64_t *o0 = result;
  uint64_t *o1 = result + (uint32_t)1U;
  uint64_t *o2 = result + (uint32_t)2U;
  uint64_t *o3 = result + (uint32_t)3U;
  uint64_t c1;
  uint64_t c2;
  uint64_t c3;
  uint64_t temp0;
  Hacl_Impl_LowLevel_mult64_0il(f, u, o0, &temp);
  c1 = Hacl_Impl_LowLevel_mult64_c(f1, u, (uint64_t)0U, o1, &temp);
  c2 = Hacl_Impl_LowLevel_mult64_c(f2, u, c1, o2, &temp);
  c3 = Hacl_Impl_LowLevel_mult64_c(f3, u, c2, o3, &temp);
  temp0 = temp;
  return c3 + temp0;
}

static uint64_t Hacl_Impl_LowLevel_mul1(uint64_t *f, uint64_t u, uint64_t *result)
{
  uint64_t temp = (uint64_t)0U;
  uint64_t f1 = f[1U];
  uint64_t f2 = f[2U];
  uint64_t f3 = f[3U];
  uint64_t *o0 = result;
  uint64_t *o1 = result + (uint32_t)1U;
  uint64_t *o2 = result + (uint32_t)2U;
  uint64_t *o3 = result + (uint32_t)3U;
  uint64_t c1;
  uint64_t c2;
  uint64_t c3;
  uint64_t temp0;
  Hacl_Impl_LowLevel_mult64_0(f, u, o0, &temp);
  c1 = Hacl_Impl_LowLevel_mult64_c(f1, u, (uint64_t)0U, o1, &temp);
  c2 = Hacl_Impl_LowLevel_mult64_c(f2, u, c1, o2, &temp);
  c3 = Hacl_Impl_LowLevel_mult64_c(f3, u, c2, o3, &temp);
  temp0 = temp;
  return c3 + temp0;
}

static uint64_t
Hacl_Impl_LowLevel_mul1_add(uint64_t *f1, uint64_t u2, uint64_t *f3, uint64_t *result)
{
  uint64_t temp[4U] = { 0U };
  uint64_t c = Hacl_Impl_LowLevel_mul1(f1, u2, temp);
  uint64_t c3 = Hacl_Impl_LowLevel_add4(temp, f3, result);
  return c + c3;
}

void Hacl_Impl_LowLevel_mul(uint64_t *f, uint64_t *r, uint64_t *out)
{
  uint64_t temp[8U] = { 0U };
  uint64_t f0 = f[0U];
  uint64_t f1 = f[1U];
  uint64_t f2 = f[2U];
  uint64_t f3 = f[3U];
  uint64_t *b0 = temp;
  uint64_t c0 = Hacl_Impl_LowLevel_mul1(r, f0, b0);
  uint64_t *b1;
  uint64_t c1;
  uint64_t *b2;
  uint64_t c2;
  uint64_t *b3;
  uint64_t c3;
  temp[4U] = c0;
  b1 = temp + (uint32_t)1U;
  c1 = Hacl_Impl_LowLevel_mul1_add(r, f1, b1, b1);
  temp[5U] = c1;
  b2 = temp + (uint32_t)2U;
  c2 = Hacl_Impl_LowLevel_mul1_add(r, f2, b2, b2);
  temp[6U] = c2;
  b3 = temp + (uint32_t)3U;
  c3 = Hacl_Impl_LowLevel_mul1_add(r, f3, b3, b3);
  temp[7U] = c3;
  memcpy(out, temp, (uint32_t)8U * sizeof temp[0U]);
}

void Hacl_Impl_LowLevel_cmovznz4(uint64_t cin, uint64_t *x, uint64_t *y, uint64_t *r)
{
  uint64_t mask = ~FStar_UInt64_eq_mask(cin, (uint64_t)0U);
  uint64_t r0 = (y[0U] & mask) | (x[0U] & ~mask);
  uint64_t r1 = (y[1U] & mask) | (x[1U] & ~mask);
  uint64_t r2 = (y[2U] & mask) | (x[2U] & ~mask);
  uint64_t r3 = (y[3U] & mask) | (x[3U] & ~mask);
  r[0U] = r0;
  r[1U] = r1;
  r[2U] = r2;
  r[3U] = r3;
}

static void Hacl_Impl_LowLevel_shift_256_impl(uint64_t *i, uint64_t *o)
{
  o[0U] = (uint64_t)0U;
  o[1U] = (uint64_t)0U;
  o[2U] = (uint64_t)0U;
  o[3U] = (uint64_t)0U;
  o[4U] = i[0U];
  o[5U] = i[1U];
  o[6U] = i[2U];
  o[7U] = i[3U];
}

void Hacl_Impl_LowLevel_shortened_mul(uint64_t *a, uint64_t b, uint64_t *result)
{
  uint64_t *result04 = result;
  uint64_t c = Hacl_Impl_LowLevel_mul1_il(a, b, result04);
  result[4U] = c;
}

void Hacl_Impl_LowLevel_shift8(uint64_t *t, uint64_t *out)
{
  uint64_t t1 = t[1U];
  uint64_t t2 = t[2U];
  uint64_t t3 = t[3U];
  uint64_t t4 = t[4U];
  uint64_t t5 = t[5U];
  uint64_t t6 = t[6U];
  uint64_t t7 = t[7U];
  out[0U] = t1;
  out[1U] = t2;
  out[2U] = t3;
  out[3U] = t4;
  out[4U] = t5;
  out[5U] = t6;
  out[6U] = t7;
  out[7U] = (uint64_t)0U;
}

static uint64_t Hacl_Impl_LowLevel_isZero_uint64(uint64_t *f)
{
  uint64_t a0 = f[0U];
  uint64_t a1 = f[1U];
  uint64_t a2 = f[2U];
  uint64_t a3 = f[3U];
  uint64_t r0 = FStar_UInt64_eq_mask(a0, (uint64_t)0U);
  uint64_t r1 = FStar_UInt64_eq_mask(a1, (uint64_t)0U);
  uint64_t r2 = FStar_UInt64_eq_mask(a2, (uint64_t)0U);
  uint64_t r3 = FStar_UInt64_eq_mask(a3, (uint64_t)0U);
  uint64_t r01 = r0 & r1;
  uint64_t r23 = r2 & r3;
  return r01 & r23;
}

bool Hacl_Impl_LowLevel_isZero_bool(uint64_t *f)
{
  uint64_t r = Hacl_Impl_LowLevel_isZero_uint64(f);
  return !(r == (uint64_t)0U);
}

void Hacl_Impl_LowLevel_uploadOneImpl(uint64_t *f)
{
  f[0U] = (uint64_t)1U;
  f[1U] = (uint64_t)0U;
  f[2U] = (uint64_t)0U;
  f[3U] = (uint64_t)0U;
}

static void Hacl_Impl_LowLevel_copy_conditional(uint64_t *out, uint64_t *x, uint64_t mask)
{
  uint64_t out_0 = out[0U];
  uint64_t out_1 = out[1U];
  uint64_t out_2 = out[2U];
  uint64_t out_3 = out[3U];
  uint64_t x_0 = x[0U];
  uint64_t x_1 = x[1U];
  uint64_t x_2 = x[2U];
  uint64_t x_3 = x[3U];
  uint64_t r_0 = out_0 ^ (mask & (out_0 ^ x_0));
  uint64_t r_1 = out_1 ^ (mask & (out_1 ^ x_1));
  uint64_t r_2 = out_2 ^ (mask & (out_2 ^ x_2));
  uint64_t r_3 = out_3 ^ (mask & (out_3 ^ x_3));
  out[0U] = r_0;
  out[1U] = r_1;
  out[2U] = r_2;
  out[3U] = r_3;
}

static uint64_t Hacl_Impl_LowLevel_compare_felem(uint64_t *a, uint64_t *b)
{
  uint64_t a_0 = a[0U];
  uint64_t a_1 = a[1U];
  uint64_t a_2 = a[2U];
  uint64_t a_3 = a[3U];
  uint64_t b_0 = b[0U];
  uint64_t b_1 = b[1U];
  uint64_t b_2 = b[2U];
  uint64_t b_3 = b[3U];
  uint64_t r_0 = FStar_UInt64_eq_mask(a_0, b_0);
  uint64_t r_1 = FStar_UInt64_eq_mask(a_1, b_1);
  uint64_t r_2 = FStar_UInt64_eq_mask(a_2, b_2);
  uint64_t r_3 = FStar_UInt64_eq_mask(a_3, b_3);
  uint64_t r01 = r_0 & r_1;
  uint64_t r23 = r_2 & r_3;
  return r01 & r23;
}

static uint64_t
Hacl_Impl_P256_LowLevel_prime256_buffer[4U] =
  {
    (uint64_t)0xffffffffffffffffU,
    (uint64_t)0xffffffffU,
    (uint64_t)0U,
    (uint64_t)0xffffffff00000001U
  };

static void Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(uint64_t *x, uint64_t *result)
{
  uint64_t tempBuffer[4U] = { 0U };
  uint64_t
  c = Hacl_Impl_LowLevel_sub4_il(x, Hacl_Impl_P256_LowLevel_prime256_buffer, tempBuffer);
  Hacl_Impl_LowLevel_cmovznz4(c, tempBuffer, x, result);
}

static void Hacl_Impl_P256_LowLevel_p256_add(uint64_t *arg1, uint64_t *arg2, uint64_t *out)
{
  uint64_t t = Hacl_Impl_LowLevel_add4(arg1, arg2, out);
  uint64_t tempBuffer[4U] = { 0U };
  uint64_t tempBufferForSubborrow = (uint64_t)0U;
  uint64_t
  c = Hacl_Impl_LowLevel_sub4_il(out, Hacl_Impl_P256_LowLevel_prime256_buffer, tempBuffer);
  uint64_t carry = Hacl_Impl_LowLevel_sub_borrow(c, t, (uint64_t)0U, &tempBufferForSubborrow);
  Hacl_Impl_LowLevel_cmovznz4(carry, tempBuffer, out, out);
}

static void Hacl_Impl_P256_LowLevel_p256_double(uint64_t *arg1, uint64_t *out)
{
  uint64_t t = Hacl_Impl_LowLevel_add4(arg1, arg1, out);
  uint64_t tempBuffer[4U] = { 0U };
  uint64_t tempBufferForSubborrow = (uint64_t)0U;
  uint64_t
  c = Hacl_Impl_LowLevel_sub4_il(out, Hacl_Impl_P256_LowLevel_prime256_buffer, tempBuffer);
  uint64_t carry = Hacl_Impl_LowLevel_sub_borrow(c, t, (uint64_t)0U, &tempBufferForSubborrow);
  Hacl_Impl_LowLevel_cmovznz4(carry, tempBuffer, out, out);
}

static void Hacl_Impl_P256_LowLevel_p256_sub(uint64_t *arg1, uint64_t *arg2, uint64_t *out)
{
  uint64_t t = Hacl_Impl_LowLevel_sub4(arg1, arg2, out);
  uint64_t t0 = (uint64_t)0U - t;
  uint64_t t1 = ((uint64_t)0U - t) >> (uint32_t)32U;
  uint64_t t2 = (uint64_t)0U;
  uint64_t t3 = t - (t << (uint32_t)32U);
  uint64_t c = Hacl_Impl_LowLevel_add4_variables(out, (uint64_t)0U, t0, t1, t2, t3, out);
}

static uint64_t Hacl_Impl_SolinasReduction_store_high_low_u(uint32_t high, uint32_t low)
{
  uint64_t as_uint64_high = (uint64_t)high;
  uint64_t as_uint64_high1 = as_uint64_high << (uint32_t)32U;
  uint64_t as_uint64_low = (uint64_t)low;
  return as_uint64_low ^ as_uint64_high1;
}

static void
Hacl_Impl_SolinasReduction_upl_zer_buffer(
  uint32_t c0,
  uint32_t c1,
  uint32_t c2,
  uint32_t c3,
  uint32_t c4,
  uint32_t c5,
  uint32_t c6,
  uint32_t c7,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = Hacl_Impl_SolinasReduction_store_high_low_u(c1, c0);
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u(c3, c2);
  uint64_t b2 = Hacl_Impl_SolinasReduction_store_high_low_u(c5, c4);
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c7, c6);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void
Hacl_Impl_SolinasReduction_upl_fir_buffer(
  uint32_t c11,
  uint32_t c12,
  uint32_t c13,
  uint32_t c14,
  uint32_t c15,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = (uint64_t)0U;
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u(c11, (uint32_t)0U);
  uint64_t b2 = Hacl_Impl_SolinasReduction_store_high_low_u(c13, c12);
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c15, c14);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void
Hacl_Impl_SolinasReduction_upl_sec_buffer(
  uint32_t c12,
  uint32_t c13,
  uint32_t c14,
  uint32_t c15,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = (uint64_t)0U;
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u(c12, (uint32_t)0U);
  uint64_t b2 = Hacl_Impl_SolinasReduction_store_high_low_u(c14, c13);
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u((uint32_t)0U, c15);
  o[0U] = b0;
  o[1U] = b1;
  o[2U] = b2;
  o[3U] = b3;
}

static void
Hacl_Impl_SolinasReduction_upl_thi_buffer(
  uint32_t c8,
  uint32_t c9,
  uint32_t c10,
  uint32_t c14,
  uint32_t c15,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = Hacl_Impl_SolinasReduction_store_high_low_u(c9, c8);
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u((uint32_t)0U, c10);
  uint64_t b2 = (uint64_t)0U;
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c15, c14);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void
Hacl_Impl_SolinasReduction_upl_for_buffer(
  uint32_t c8,
  uint32_t c9,
  uint32_t c10,
  uint32_t c11,
  uint32_t c13,
  uint32_t c14,
  uint32_t c15,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = Hacl_Impl_SolinasReduction_store_high_low_u(c10, c9);
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u(c13, c11);
  uint64_t b2 = Hacl_Impl_SolinasReduction_store_high_low_u(c15, c14);
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c8, c13);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void
Hacl_Impl_SolinasReduction_upl_fif_buffer(
  uint32_t c8,
  uint32_t c10,
  uint32_t c11,
  uint32_t c12,
  uint32_t c13,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = Hacl_Impl_SolinasReduction_store_high_low_u(c12, c11);
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u((uint32_t)0U, c13);
  uint64_t b2 = (uint64_t)0U;
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c10, c8);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void
Hacl_Impl_SolinasReduction_upl_six_buffer(
  uint32_t c9,
  uint32_t c11,
  uint32_t c12,
  uint32_t c13,
  uint32_t c14,
  uint32_t c15,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = Hacl_Impl_SolinasReduction_store_high_low_u(c13, c12);
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u(c15, c14);
  uint64_t b2 = (uint64_t)0U;
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c11, c9);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void
Hacl_Impl_SolinasReduction_upl_sev_buffer(
  uint32_t c8,
  uint32_t c9,
  uint32_t c10,
  uint32_t c12,
  uint32_t c13,
  uint32_t c14,
  uint32_t c15,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = Hacl_Impl_SolinasReduction_store_high_low_u(c14, c13);
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u(c8, c15);
  uint64_t b2 = Hacl_Impl_SolinasReduction_store_high_low_u(c10, c9);
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c12, (uint32_t)0U);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void
Hacl_Impl_SolinasReduction_upl_eig_buffer(
  uint32_t c9,
  uint32_t c10,
  uint32_t c11,
  uint32_t c12,
  uint32_t c13,
  uint32_t c14,
  uint32_t c15,
  uint64_t *temp,
  uint64_t *o
)
{
  uint64_t b0 = Hacl_Impl_SolinasReduction_store_high_low_u(c15, c14);
  uint64_t b1 = Hacl_Impl_SolinasReduction_store_high_low_u(c9, (uint32_t)0U);
  uint64_t b2 = Hacl_Impl_SolinasReduction_store_high_low_u(c11, c10);
  uint64_t b3 = Hacl_Impl_SolinasReduction_store_high_low_u(c13, (uint32_t)0U);
  temp[0U] = b0;
  temp[1U] = b1;
  temp[2U] = b2;
  temp[3U] = b3;
  Hacl_Impl_P256_LowLevel_reduction_prime_2prime_impl(temp, o);
}

static void Hacl_Impl_SolinasReduction_solinas_reduction_impl(uint64_t *i, uint64_t *o)
{
  uint64_t tempBuffer[36U] = { 0U };
  uint64_t i0 = i[0U];
  uint64_t i1 = i[1U];
  uint64_t i2 = i[2U];
  uint64_t i3 = i[3U];
  uint64_t i4 = i[4U];
  uint64_t i5 = i[5U];
  uint64_t i6 = i[6U];
  uint64_t i7 = i[7U];
  uint32_t c0 = (uint32_t)i0;
  uint32_t c1 = (uint32_t)(i0 >> (uint32_t)32U);
  uint32_t c2 = (uint32_t)i1;
  uint32_t c3 = (uint32_t)(i1 >> (uint32_t)32U);
  uint32_t c4 = (uint32_t)i2;
  uint32_t c5 = (uint32_t)(i2 >> (uint32_t)32U);
  uint32_t c6 = (uint32_t)i3;
  uint32_t c7 = (uint32_t)(i3 >> (uint32_t)32U);
  uint32_t c8 = (uint32_t)i4;
  uint32_t c9 = (uint32_t)(i4 >> (uint32_t)32U);
  uint32_t c10 = (uint32_t)i5;
  uint32_t c11 = (uint32_t)(i5 >> (uint32_t)32U);
  uint32_t c12 = (uint32_t)i6;
  uint32_t c13 = (uint32_t)(i6 >> (uint32_t)32U);
  uint32_t c14 = (uint32_t)i7;
  uint32_t c15 = (uint32_t)(i7 >> (uint32_t)32U);
  uint64_t redBuffer[4U] = { 0U };
  uint64_t *t610 = tempBuffer + (uint32_t)24U;
  uint64_t *t710 = tempBuffer + (uint32_t)28U;
  uint64_t *t810 = tempBuffer + (uint32_t)32U;
  uint64_t *t010 = tempBuffer;
  uint64_t *t110 = tempBuffer + (uint32_t)4U;
  uint64_t *t210 = tempBuffer + (uint32_t)8U;
  uint64_t *t310 = tempBuffer + (uint32_t)12U;
  uint64_t *t410 = tempBuffer + (uint32_t)16U;
  uint64_t *t510 = tempBuffer + (uint32_t)20U;
  uint64_t *t01;
  uint64_t *t11;
  uint64_t *t21;
  uint64_t *t31;
  uint64_t *t41;
  uint64_t *t51;
  uint64_t *t61;
  uint64_t *t71;
  uint64_t *t81;
  Hacl_Impl_SolinasReduction_upl_zer_buffer(c0, c1, c2, c3, c4, c5, c6, c7, redBuffer, t010);
  Hacl_Impl_SolinasReduction_upl_fir_buffer(c11, c12, c13, c14, c15, redBuffer, t110);
  Hacl_Impl_SolinasReduction_upl_sec_buffer(c12, c13, c14, c15, redBuffer, t210);
  Hacl_Impl_SolinasReduction_upl_thi_buffer(c8, c9, c10, c14, c15, redBuffer, t310);
  Hacl_Impl_SolinasReduction_upl_for_buffer(c8, c9, c10, c11, c13, c14, c15, redBuffer, t410);
  Hacl_Impl_SolinasReduction_upl_fif_buffer(c8, c10, c11, c12, c13, redBuffer, t510);
  Hacl_Impl_SolinasReduction_upl_six_buffer(c9, c11, c12, c13, c14, c15, redBuffer, t610);
  Hacl_Impl_SolinasReduction_upl_sev_buffer(c8, c9, c10, c12, c13, c14, c15, redBuffer, t710);
  Hacl_Impl_SolinasReduction_upl_eig_buffer(c9, c10, c11, c12, c13, c14, c15, redBuffer, t810);
  t01 = tempBuffer;
  t11 = tempBuffer + (uint32_t)4U;
  t21 = tempBuffer + (uint32_t)8U;
  t31 = tempBuffer + (uint32_t)12U;
  t41 = tempBuffer + (uint32_t)16U;
  t51 = tempBuffer + (uint32_t)20U;
  t61 = tempBuffer + (uint32_t)24U;
  t71 = tempBuffer + (uint32_t)28U;
  t81 = tempBuffer + (uint32_t)32U;
  Hacl_Impl_P256_LowLevel_p256_double(t21, t21);
  Hacl_Impl_P256_LowLevel_p256_double(t11, t11);
  Hacl_Impl_P256_LowLevel_p256_add(t01, t11, o);
  Hacl_Impl_P256_LowLevel_p256_add(t21, o, o);
  Hacl_Impl_P256_LowLevel_p256_add(t31, o, o);
  Hacl_Impl_P256_LowLevel_p256_add(t41, o, o);
  Hacl_Impl_P256_LowLevel_p256_sub(o, t51, o);
  Hacl_Impl_P256_LowLevel_p256_sub(o, t61, o);
  Hacl_Impl_P256_LowLevel_p256_sub(o, t71, o);
  Hacl_Impl_P256_LowLevel_p256_sub(o, t81, o);
}

static void
Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer_by_one(
  uint64_t *a,
  uint64_t *result
)
{
  uint64_t t[8U] = { 0U };
  uint64_t *t_low = t;
  uint64_t round2[8U] = { 0U };
  uint64_t round4[8U] = { 0U };
  memcpy(t_low, a, (uint32_t)4U * sizeof a[0U]);
  {
    uint64_t tempRound[8U] = { 0U };
    uint64_t t20[8U] = { 0U };
    uint64_t t30[8U] = { 0U };
    uint64_t t10 = t[0U];
    uint64_t uu____0;
    Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t10, t20);
    uu____0 = Hacl_Impl_LowLevel_add8(t, t20, t30);
    Hacl_Impl_LowLevel_shift8(t30, tempRound);
    {
      uint64_t t21[8U] = { 0U };
      uint64_t t31[8U] = { 0U };
      uint64_t t11 = tempRound[0U];
      uint64_t uu____1;
      Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t11, t21);
      uu____1 = Hacl_Impl_LowLevel_add8(tempRound, t21, t31);
      Hacl_Impl_LowLevel_shift8(t31, round2);
      {
        uint64_t tempRound0[8U] = { 0U };
        uint64_t t2[8U] = { 0U };
        uint64_t t32[8U] = { 0U };
        uint64_t t12 = round2[0U];
        uint64_t uu____2;
        Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t12, t2);
        uu____2 = Hacl_Impl_LowLevel_add8(round2, t2, t32);
        Hacl_Impl_LowLevel_shift8(t32, tempRound0);
        {
          uint64_t t22[8U] = { 0U };
          uint64_t t3[8U] = { 0U };
          uint64_t t1 = tempRound0[0U];
          uint64_t uu____3;
          Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t1, t22);
          uu____3 = Hacl_Impl_LowLevel_add8(tempRound0, t22, t3);
          Hacl_Impl_LowLevel_shift8(t3, round4);
          {
            uint64_t tempBuffer[4U] = { 0U };
            uint64_t tempBufferForSubborrow = (uint64_t)0U;
            uint64_t cin = round4[4U];
            uint64_t *x_ = round4;
            uint64_t
            c = Hacl_Impl_LowLevel_sub4_il(x_, Hacl_Impl_P256_LowLevel_prime256_buffer, tempBuffer);
            uint64_t
            carry = Hacl_Impl_LowLevel_sub_borrow(c, cin, (uint64_t)0U, &tempBufferForSubborrow);
            Hacl_Impl_LowLevel_cmovznz4(carry, tempBuffer, x_, result);
          }
        }
      }
    }
  }
}

static void
Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(
  uint64_t *a,
  uint64_t *b,
  uint64_t *result
)
{
  uint64_t t[8U] = { 0U };
  uint64_t round2[8U] = { 0U };
  uint64_t round4[8U] = { 0U };
  Hacl_Impl_LowLevel_mul(a, b, t);
  {
    uint64_t tempRound[8U] = { 0U };
    uint64_t t20[8U] = { 0U };
    uint64_t t30[8U] = { 0U };
    uint64_t t10 = t[0U];
    uint64_t uu____0;
    Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t10, t20);
    uu____0 = Hacl_Impl_LowLevel_add8(t, t20, t30);
    Hacl_Impl_LowLevel_shift8(t30, tempRound);
    {
      uint64_t t21[8U] = { 0U };
      uint64_t t31[8U] = { 0U };
      uint64_t t11 = tempRound[0U];
      uint64_t uu____1;
      Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t11, t21);
      uu____1 = Hacl_Impl_LowLevel_add8(tempRound, t21, t31);
      Hacl_Impl_LowLevel_shift8(t31, round2);
      {
        uint64_t tempRound0[8U] = { 0U };
        uint64_t t2[8U] = { 0U };
        uint64_t t32[8U] = { 0U };
        uint64_t t12 = round2[0U];
        uint64_t uu____2;
        Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t12, t2);
        uu____2 = Hacl_Impl_LowLevel_add8(round2, t2, t32);
        Hacl_Impl_LowLevel_shift8(t32, tempRound0);
        {
          uint64_t t22[8U] = { 0U };
          uint64_t t3[8U] = { 0U };
          uint64_t t1 = tempRound0[0U];
          uint64_t uu____3;
          Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_P256_LowLevel_prime256_buffer, t1, t22);
          uu____3 = Hacl_Impl_LowLevel_add8(tempRound0, t22, t3);
          Hacl_Impl_LowLevel_shift8(t3, round4);
          {
            uint64_t tempBuffer[4U] = { 0U };
            uint64_t tempBufferForSubborrow = (uint64_t)0U;
            uint64_t cin = round4[4U];
            uint64_t *x_ = round4;
            uint64_t
            c = Hacl_Impl_LowLevel_sub4_il(x_, Hacl_Impl_P256_LowLevel_prime256_buffer, tempBuffer);
            uint64_t
            carry = Hacl_Impl_LowLevel_sub_borrow(c, cin, (uint64_t)0U, &tempBufferForSubborrow);
            Hacl_Impl_LowLevel_cmovznz4(carry, tempBuffer, x_, result);
          }
        }
      }
    }
  }
}

static void Hacl_Impl_P256_MontgomeryMultiplication_fsquarePowN(uint32_t n1, uint64_t *a)
{
  uint32_t i;
  for (i = (uint32_t)0U; i < n1; i = i + (uint32_t)1U)
  {
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(a, a, a);
  }
}

static void
Hacl_Impl_P256_MontgomeryMultiplication_fsquarePowNminusOne(
  uint32_t n1,
  uint64_t *a,
  uint64_t *b
)
{
  uint32_t i;
  b[0U] = (uint64_t)1U;
  b[1U] = (uint64_t)18446744069414584320U;
  b[2U] = (uint64_t)18446744073709551615U;
  b[3U] = (uint64_t)4294967294U;
  for (i = (uint32_t)0U; i < n1; i = i + (uint32_t)1U)
  {
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(b, a, b);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(a, a, a);
  }
}

static void
Hacl_Impl_P256_MontgomeryMultiplication_exponent(
  uint64_t *a,
  uint64_t *result,
  uint64_t *tempBuffer
)
{
  uint64_t *buffer_norm_1 = tempBuffer;
  uint64_t *buffer_result1 = tempBuffer + (uint32_t)4U;
  uint64_t *buffer_result2 = tempBuffer + (uint32_t)8U;
  uint64_t *buffer_norm_3 = tempBuffer + (uint32_t)12U;
  uint64_t *buffer_result3 = tempBuffer + (uint32_t)16U;
  uint64_t *buffer_a0;
  uint64_t *buffer_b0;
  uint64_t *buffer_a;
  uint64_t *buffer_b;
  memcpy(buffer_norm_1, a, (uint32_t)4U * sizeof a[0U]);
  buffer_a0 = buffer_norm_1;
  buffer_b0 = buffer_norm_1 + (uint32_t)4U;
  Hacl_Impl_P256_MontgomeryMultiplication_fsquarePowNminusOne((uint32_t)32U,
    buffer_a0,
    buffer_b0);
  Hacl_Impl_P256_MontgomeryMultiplication_fsquarePowN((uint32_t)224U, buffer_b0);
  memcpy(buffer_result2, a, (uint32_t)4U * sizeof a[0U]);
  Hacl_Impl_P256_MontgomeryMultiplication_fsquarePowN((uint32_t)192U, buffer_result2);
  memcpy(buffer_norm_3, a, (uint32_t)4U * sizeof a[0U]);
  buffer_a = buffer_norm_3;
  buffer_b = buffer_norm_3 + (uint32_t)4U;
  Hacl_Impl_P256_MontgomeryMultiplication_fsquarePowNminusOne((uint32_t)94U, buffer_a, buffer_b);
  Hacl_Impl_P256_MontgomeryMultiplication_fsquarePowN((uint32_t)2U, buffer_b);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(buffer_result1,
    buffer_result2,
    buffer_result1);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(buffer_result1,
    buffer_result3,
    buffer_result1);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(buffer_result1,
    a,
    buffer_result1);
  memcpy(result, buffer_result1, (uint32_t)4U * sizeof buffer_result1[0U]);
}

static void Hacl_Impl_P256_Arithmetics_quatre(uint64_t *a, uint64_t *result)
{
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(a, a, result);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(result,
    result,
    result);
}

static void Hacl_Impl_P256_Arithmetics_multByTwo(uint64_t *a, uint64_t *out)
{
  Hacl_Impl_P256_LowLevel_p256_add(a, a, out);
}

static void Hacl_Impl_P256_Arithmetics_multByThree(uint64_t *a, uint64_t *result)
{
  Hacl_Impl_P256_Arithmetics_multByTwo(a, result);
  Hacl_Impl_P256_LowLevel_p256_add(a, result, result);
}

static void Hacl_Impl_P256_Arithmetics_multByFour(uint64_t *a, uint64_t *result)
{
  Hacl_Impl_P256_Arithmetics_multByTwo(a, result);
  Hacl_Impl_P256_Arithmetics_multByTwo(result, result);
}

static void Hacl_Impl_P256_Arithmetics_multByEight(uint64_t *a, uint64_t *result)
{
  Hacl_Impl_P256_Arithmetics_multByTwo(a, result);
  Hacl_Impl_P256_Arithmetics_multByTwo(result, result);
  Hacl_Impl_P256_Arithmetics_multByTwo(result, result);
}

static void Hacl_Impl_P256_Arithmetics_multByMinusThree(uint64_t *a, uint64_t *result)
{
  Hacl_Impl_P256_Arithmetics_multByThree(a, result);
  {
    uint64_t zeros1[4U] = { 0U };
    Hacl_Impl_P256_LowLevel_p256_sub(zeros1, result, result);
  }
}

static void Hacl_Spec_P256_Ladder_cswap(uint64_t bit, uint64_t *p1, uint64_t *p2)
{
  uint64_t mask = (uint64_t)0U - bit;
  uint32_t i;
  for (i = (uint32_t)0U; i < (uint32_t)12U; i = i + (uint32_t)1U)
  {
    uint64_t dummy = mask & (p1[i] ^ p2[i]);
    p1[i] = p1[i] ^ dummy;
    p2[i] = p2[i] ^ dummy;
  }
}

static void
Hacl_Impl_P256_PointDouble_point_double_compute_s_m(
  uint64_t *p,
  uint64_t *s1,
  uint64_t *m,
  uint64_t *tempBuffer
)
{
  uint64_t *px = p;
  uint64_t *py = p + (uint32_t)4U;
  uint64_t *pz = p + (uint32_t)8U;
  uint64_t *yy = tempBuffer;
  uint64_t *xyy = tempBuffer + (uint32_t)4U;
  uint64_t *zzzz = tempBuffer + (uint32_t)8U;
  uint64_t *minThreeZzzz = tempBuffer + (uint32_t)12U;
  uint64_t *xx = tempBuffer + (uint32_t)16U;
  uint64_t *threeXx = tempBuffer + (uint32_t)20U;
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(py, py, yy);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(px, yy, xyy);
  Hacl_Impl_P256_Arithmetics_quatre(pz, zzzz);
  Hacl_Impl_P256_Arithmetics_multByMinusThree(zzzz, minThreeZzzz);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(px, px, xx);
  Hacl_Impl_P256_Arithmetics_multByThree(xx, threeXx);
  Hacl_Impl_P256_LowLevel_p256_add(minThreeZzzz, threeXx, m);
  Hacl_Impl_P256_Arithmetics_multByFour(xyy, s1);
}

static void
Hacl_Impl_P256_PointDouble_point_double_compute_y3(
  uint64_t *pY,
  uint64_t *y3,
  uint64_t *x3,
  uint64_t *s1,
  uint64_t *m,
  uint64_t *tempBuffer
)
{
  uint64_t *yyyy = tempBuffer;
  uint64_t *eightYyyy = tempBuffer + (uint32_t)4U;
  uint64_t *sx3 = tempBuffer + (uint32_t)8U;
  uint64_t *msx3 = tempBuffer + (uint32_t)12U;
  Hacl_Impl_P256_Arithmetics_quatre(pY, yyyy);
  Hacl_Impl_P256_Arithmetics_multByEight(yyyy, eightYyyy);
  Hacl_Impl_P256_LowLevel_p256_sub(s1, x3, sx3);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(m, sx3, msx3);
  Hacl_Impl_P256_LowLevel_p256_sub(msx3, eightYyyy, y3);
}

static void
Hacl_Impl_P256_PointDouble_point_double(uint64_t *p, uint64_t *result, uint64_t *tempBuffer)
{
  uint64_t *s1 = tempBuffer;
  uint64_t *m = tempBuffer + (uint32_t)4U;
  uint64_t *buffer_for_s_m = tempBuffer + (uint32_t)8U;
  uint64_t *buffer_for_x3 = tempBuffer + (uint32_t)32U;
  uint64_t *buffer_for_y3 = tempBuffer + (uint32_t)40U;
  uint64_t *pypz = tempBuffer + (uint32_t)56U;
  uint64_t *x3 = tempBuffer + (uint32_t)60U;
  uint64_t *y3 = tempBuffer + (uint32_t)64U;
  uint64_t *z3 = tempBuffer + (uint32_t)68U;
  uint64_t *pY = p + (uint32_t)4U;
  uint64_t *pZ = p + (uint32_t)8U;
  uint64_t *twoS;
  uint64_t *mm;
  Hacl_Impl_P256_PointDouble_point_double_compute_s_m(p, s1, m, buffer_for_s_m);
  twoS = buffer_for_x3;
  mm = buffer_for_x3 + (uint32_t)4U;
  Hacl_Impl_P256_Arithmetics_multByTwo(s1, twoS);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(m, m, mm);
  Hacl_Impl_P256_LowLevel_p256_sub(mm, twoS, x3);
  Hacl_Impl_P256_PointDouble_point_double_compute_y3(pY, y3, x3, s1, m, buffer_for_y3);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(pY, pZ, pypz);
  Hacl_Impl_P256_Arithmetics_multByTwo(pypz, z3);
  memcpy(result, x3, (uint32_t)4U * sizeof x3[0U]);
  memcpy(result + (uint32_t)4U, y3, (uint32_t)4U * sizeof y3[0U]);
  memcpy(result + (uint32_t)8U, z3, (uint32_t)4U * sizeof z3[0U]);
}

static void
Hacl_Impl_P256_PointAdd_copy_point_conditional(
  uint64_t *x3_out,
  uint64_t *y3_out,
  uint64_t *z3_out,
  uint64_t *p,
  uint64_t *maskPoint
)
{
  uint64_t *z = maskPoint + (uint32_t)8U;
  uint64_t mask = Hacl_Impl_LowLevel_isZero_uint64(z);
  uint64_t *p_x = p;
  uint64_t *p_y = p + (uint32_t)4U;
  uint64_t *p_z = p + (uint32_t)8U;
  Hacl_Impl_LowLevel_copy_conditional(x3_out, p_x, mask);
  Hacl_Impl_LowLevel_copy_conditional(y3_out, p_y, mask);
  Hacl_Impl_LowLevel_copy_conditional(z3_out, p_z, mask);
}

static void
Hacl_Impl_P256_PointAdd_point_add(
  uint64_t *p,
  uint64_t *q,
  uint64_t *result,
  uint64_t *tempBuffer
)
{
  uint64_t *z1 = p + (uint32_t)8U;
  uint64_t *z2 = q + (uint32_t)8U;
  uint64_t *tempBuffer16 = tempBuffer;
  uint64_t *u11 = tempBuffer + (uint32_t)16U;
  uint64_t *u2 = tempBuffer + (uint32_t)20U;
  uint64_t *s1 = tempBuffer + (uint32_t)24U;
  uint64_t *s2 = tempBuffer + (uint32_t)28U;
  uint64_t *h = tempBuffer + (uint32_t)32U;
  uint64_t *r = tempBuffer + (uint32_t)36U;
  uint64_t *uh = tempBuffer + (uint32_t)40U;
  uint64_t *hCube = tempBuffer + (uint32_t)44U;
  uint64_t *tempBuffer28 = tempBuffer + (uint32_t)60U;
  uint64_t *pX = p;
  uint64_t *pY = p + (uint32_t)4U;
  uint64_t *pZ0 = p + (uint32_t)8U;
  uint64_t *qX = q;
  uint64_t *qY = q + (uint32_t)4U;
  uint64_t *qZ0 = q + (uint32_t)8U;
  uint64_t *z2Square = tempBuffer16;
  uint64_t *z1Square = tempBuffer16 + (uint32_t)4U;
  uint64_t *z2Cube = tempBuffer16 + (uint32_t)8U;
  uint64_t *z1Cube = tempBuffer16 + (uint32_t)12U;
  uint64_t one1;
  uint64_t two;
  uint64_t z1NotZero;
  uint64_t z2NotZero;
  uint64_t pointsInf;
  uint64_t onetwo;
  uint64_t result1;
  bool flag;
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(qZ0, qZ0, z2Square);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(pZ0, pZ0, z1Square);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z2Square,
    qZ0,
    z2Cube);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z1Square,
    pZ0,
    z1Cube);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z2Square, pX, u11);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z1Square, qX, u2);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z2Cube, pY, s1);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z1Cube, qY, s2);
  one1 = Hacl_Impl_LowLevel_compare_felem(u11, u2);
  two = Hacl_Impl_LowLevel_compare_felem(s1, s2);
  z1NotZero = Hacl_Impl_LowLevel_isZero_uint64(z1);
  z2NotZero = Hacl_Impl_LowLevel_isZero_uint64(z2);
  pointsInf = ~z1NotZero & ~z2NotZero;
  onetwo = one1 & two;
  result1 = onetwo & pointsInf;
  flag = result1 == (uint64_t)0xffffffffffffffffU;
  if (flag)
  {
    Hacl_Impl_P256_PointDouble_point_double(p, result, tempBuffer);
  }
  else
  {
    uint64_t *temp = tempBuffer16;
    uint64_t *pZ;
    uint64_t *qZ;
    uint64_t *tempBuffer161;
    uint64_t *x3_out1;
    uint64_t *y3_out1;
    uint64_t *z3_out1;
    uint64_t *rSquare;
    uint64_t *rH;
    uint64_t *twoUh;
    uint64_t *s1hCube;
    uint64_t *u1hx3;
    uint64_t *ru1hx3;
    uint64_t *z1z2;
    Hacl_Impl_P256_LowLevel_p256_sub(u2, u11, h);
    Hacl_Impl_P256_LowLevel_p256_sub(s2, s1, r);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(h, h, temp);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(temp, u11, uh);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(temp, h, hCube);
    pZ = p + (uint32_t)8U;
    qZ = q + (uint32_t)8U;
    tempBuffer161 = tempBuffer28;
    x3_out1 = tempBuffer28 + (uint32_t)16U;
    y3_out1 = tempBuffer28 + (uint32_t)20U;
    z3_out1 = tempBuffer28 + (uint32_t)24U;
    rSquare = tempBuffer161;
    rH = tempBuffer161 + (uint32_t)4U;
    twoUh = tempBuffer161 + (uint32_t)8U;
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(r, r, rSquare);
    Hacl_Impl_P256_LowLevel_p256_sub(rSquare, hCube, rH);
    Hacl_Impl_P256_Arithmetics_multByTwo(uh, twoUh);
    Hacl_Impl_P256_LowLevel_p256_sub(rH, twoUh, x3_out1);
    s1hCube = tempBuffer161;
    u1hx3 = tempBuffer161 + (uint32_t)4U;
    ru1hx3 = tempBuffer161 + (uint32_t)8U;
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(s1, hCube, s1hCube);
    Hacl_Impl_P256_LowLevel_p256_sub(uh, x3_out1, u1hx3);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(u1hx3, r, ru1hx3);
    Hacl_Impl_P256_LowLevel_p256_sub(ru1hx3, s1hCube, y3_out1);
    z1z2 = tempBuffer161;
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(pZ, qZ, z1z2);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z1z2, h, z3_out1);
    Hacl_Impl_P256_PointAdd_copy_point_conditional(x3_out1, y3_out1, z3_out1, q, p);
    Hacl_Impl_P256_PointAdd_copy_point_conditional(x3_out1, y3_out1, z3_out1, p, q);
    memcpy(result, x3_out1, (uint32_t)4U * sizeof x3_out1[0U]);
    memcpy(result + (uint32_t)4U, y3_out1, (uint32_t)4U * sizeof y3_out1[0U]);
    memcpy(result + (uint32_t)8U, z3_out1, (uint32_t)4U * sizeof z3_out1[0U]);
  }
}

void pointToDomain(uint64_t *p, uint64_t *result)
{
  uint64_t *p_x = p;
  uint64_t *p_y = p + (uint32_t)4U;
  uint64_t *p_z = p + (uint32_t)8U;
  uint64_t *r_x = result;
  uint64_t *r_y = result + (uint32_t)4U;
  uint64_t *r_z = result + (uint32_t)8U;
  uint64_t multBuffer[8U] = { 0U };
  Hacl_Impl_LowLevel_shift_256_impl(p_x, multBuffer);
  Hacl_Impl_SolinasReduction_solinas_reduction_impl(multBuffer, r_x);
  {
    uint64_t multBuffer0[8U] = { 0U };
    Hacl_Impl_LowLevel_shift_256_impl(p_y, multBuffer0);
    Hacl_Impl_SolinasReduction_solinas_reduction_impl(multBuffer0, r_y);
    {
      uint64_t multBuffer1[8U] = { 0U };
      Hacl_Impl_LowLevel_shift_256_impl(p_z, multBuffer1);
      Hacl_Impl_SolinasReduction_solinas_reduction_impl(multBuffer1, r_z);
    }
  }
}

static void fromDomain(uint64_t *f, uint64_t *result)
{
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer_by_one(f, result);
}

void pointFromDomain(uint64_t *p, uint64_t *result)
{
  uint64_t *p_x = p;
  uint64_t *p_y = p + (uint32_t)4U;
  uint64_t *p_z = p + (uint32_t)8U;
  uint64_t *r_x = result;
  uint64_t *r_y = result + (uint32_t)4U;
  uint64_t *r_z = result + (uint32_t)8U;
  fromDomain(p_x, r_x);
  fromDomain(p_y, r_y);
  fromDomain(p_z, r_z);
}

static void copy_point(uint64_t *p, uint64_t *result)
{
  memcpy(result, p, (uint32_t)12U * sizeof p[0U]);
}

uint64_t isPointAtInfinityPrivate(uint64_t *p)
{
  uint64_t z0 = p[8U];
  uint64_t z1 = p[9U];
  uint64_t z2 = p[10U];
  uint64_t z3 = p[11U];
  uint64_t z0_zero = FStar_UInt64_eq_mask(z0, (uint64_t)0U);
  uint64_t z1_zero = FStar_UInt64_eq_mask(z1, (uint64_t)0U);
  uint64_t z2_zero = FStar_UInt64_eq_mask(z2, (uint64_t)0U);
  uint64_t z3_zero = FStar_UInt64_eq_mask(z3, (uint64_t)0U);
  return (z0_zero & z1_zero) & (z2_zero & z3_zero);
}

void norm(uint64_t *p, uint64_t *resultPoint, uint64_t *tempBuffer)
{
  uint64_t *xf = p;
  uint64_t *yf = p + (uint32_t)4U;
  uint64_t *zf = p + (uint32_t)8U;
  uint64_t *z2f = tempBuffer + (uint32_t)4U;
  uint64_t *z3f = tempBuffer + (uint32_t)8U;
  uint64_t *tempBuffer20 = tempBuffer + (uint32_t)12U;
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(zf, zf, z2f);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z2f, zf, z3f);
  Hacl_Impl_P256_MontgomeryMultiplication_exponent(z2f, z2f, tempBuffer20);
  Hacl_Impl_P256_MontgomeryMultiplication_exponent(z3f, z3f, tempBuffer20);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(xf, z2f, z2f);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(yf, z3f, z3f);
  {
    uint64_t zeroBuffer[4U] = { 0U };
    uint64_t *resultX = resultPoint;
    uint64_t *resultY = resultPoint + (uint32_t)4U;
    uint64_t *resultZ = resultPoint + (uint32_t)8U;
    uint64_t bit = isPointAtInfinityPrivate(p);
    fromDomain(z2f, resultX);
    fromDomain(z3f, resultY);
    Hacl_Impl_LowLevel_uploadOneImpl(resultZ);
    Hacl_Impl_LowLevel_copy_conditional(resultZ, zeroBuffer, bit);
  }
}

void normX(uint64_t *p, uint64_t *result, uint64_t *tempBuffer)
{
  uint64_t *xf = p;
  uint64_t *zf = p + (uint32_t)8U;
  uint64_t *z2f = tempBuffer + (uint32_t)4U;
  uint64_t *tempBuffer20 = tempBuffer + (uint32_t)12U;
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(zf, zf, z2f);
  Hacl_Impl_P256_MontgomeryMultiplication_exponent(z2f, z2f, tempBuffer20);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(z2f, xf, z2f);
  fromDomain(z2f, result);
}

static void zero_buffer(uint64_t *p)
{
  p[0U] = (uint64_t)0U;
  p[1U] = (uint64_t)0U;
  p[2U] = (uint64_t)0U;
  p[3U] = (uint64_t)0U;
  p[4U] = (uint64_t)0U;
  p[5U] = (uint64_t)0U;
  p[6U] = (uint64_t)0U;
  p[7U] = (uint64_t)0U;
  p[8U] = (uint64_t)0U;
  p[9U] = (uint64_t)0U;
  p[10U] = (uint64_t)0U;
  p[11U] = (uint64_t)0U;
}

static void uploadBasePoint(uint64_t *p)
{
  p[0U] = (uint64_t)8784043285714375740U;
  p[1U] = (uint64_t)8483257759279461889U;
  p[2U] = (uint64_t)8789745728267363600U;
  p[3U] = (uint64_t)1770019616739251654U;
  p[4U] = (uint64_t)15992936863339206154U;
  p[5U] = (uint64_t)10037038012062884956U;
  p[6U] = (uint64_t)15197544864945402661U;
  p[7U] = (uint64_t)9615747158586711429U;
  p[8U] = (uint64_t)1U;
  p[9U] = (uint64_t)18446744069414584320U;
  p[10U] = (uint64_t)18446744073709551615U;
  p[11U] = (uint64_t)4294967294U;
}

void
scalarMultiplicationWithoutNorm(
  uint64_t *p,
  uint64_t *result,
  uint8_t *scalar,
  uint64_t *tempBuffer
)
{
  uint64_t *q = tempBuffer;
  uint64_t *buff;
  zero_buffer(q);
  buff = tempBuffer + (uint32_t)12U;
  pointToDomain(p, result);
  {
    uint32_t i;
    for (i = (uint32_t)0U; i < (uint32_t)256U; i = i + (uint32_t)1U)
    {
      uint32_t bit0 = (uint32_t)255U - i;
      uint64_t bit = (uint64_t)(scalar[bit0 / (uint32_t)8U] >> bit0 % (uint32_t)8U & (uint8_t)1U);
      Hacl_Spec_P256_Ladder_cswap(bit, q, result);
      Hacl_Impl_P256_PointAdd_point_add(q, result, result, buff);
      Hacl_Impl_P256_PointDouble_point_double(q, q, buff);
      Hacl_Spec_P256_Ladder_cswap(bit, q, result);
    }
  }
  copy_point(q, result);
}

void secretToPublic(uint64_t *result, uint8_t *scalar, uint64_t *tempBuffer)
{
  uint64_t basePoint[12U] = { 0U };
  uint64_t *q;
  uint64_t *buff;
  uploadBasePoint(basePoint);
  q = tempBuffer;
  buff = tempBuffer + (uint32_t)12U;
  zero_buffer(q);
  {
    uint32_t i;
    for (i = (uint32_t)0U; i < (uint32_t)256U; i = i + (uint32_t)1U)
    {
      uint32_t bit0 = (uint32_t)255U - i;
      uint64_t bit = (uint64_t)(scalar[bit0 / (uint32_t)8U] >> bit0 % (uint32_t)8U & (uint8_t)1U);
      Hacl_Spec_P256_Ladder_cswap(bit, q, basePoint);
      Hacl_Impl_P256_PointAdd_point_add(q, basePoint, basePoint, buff);
      Hacl_Impl_P256_PointDouble_point_double(q, q, buff);
      Hacl_Spec_P256_Ladder_cswap(bit, q, basePoint);
    }
  }
  norm(q, result, buff);
}

void secretToPublicWithoutNorm(uint64_t *result, uint8_t *scalar, uint64_t *tempBuffer)
{
  uint64_t basePoint[12U] = { 0U };
  uint64_t *q;
  uint64_t *buff;
  uploadBasePoint(basePoint);
  q = tempBuffer;
  buff = tempBuffer + (uint32_t)12U;
  zero_buffer(q);
  {
    uint32_t i;
    for (i = (uint32_t)0U; i < (uint32_t)256U; i = i + (uint32_t)1U)
    {
      uint32_t bit0 = (uint32_t)255U - i;
      uint64_t bit = (uint64_t)(scalar[bit0 / (uint32_t)8U] >> bit0 % (uint32_t)8U & (uint8_t)1U);
      Hacl_Spec_P256_Ladder_cswap(bit, q, basePoint);
      Hacl_Impl_P256_PointAdd_point_add(q, basePoint, basePoint, buff);
      Hacl_Impl_P256_PointDouble_point_double(q, q, buff);
      Hacl_Spec_P256_Ladder_cswap(bit, q, basePoint);
    }
  }
  copy_point(q, result);
}

bool isPointAtInfinity(uint64_t *p)
{
  uint64_t z0 = p[8U];
  uint64_t z1 = p[9U];
  uint64_t z2 = p[10U];
  uint64_t z3 = p[11U];
  bool z0_zero = z0 == (uint64_t)0U;
  bool z1_zero = z1 == (uint64_t)0U;
  bool z2_zero = z2 == (uint64_t)0U;
  bool z3_zero = z3 == (uint64_t)0U;
  return z0_zero && z1_zero && z2_zero && z3_zero;
}

bool isPointOnCurve(uint64_t *p)
{
  uint64_t y2Buffer[4U] = { 0U };
  uint64_t xBuffer[4U] = { 0U };
  uint64_t *x = p;
  uint64_t *y = p + (uint32_t)4U;
  uint64_t multBuffer0[8U] = { 0U };
  Hacl_Impl_LowLevel_shift_256_impl(y, multBuffer0);
  Hacl_Impl_SolinasReduction_solinas_reduction_impl(multBuffer0, y2Buffer);
  Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(y2Buffer,
    y2Buffer,
    y2Buffer);
  {
    uint64_t xToDomainBuffer[4U] = { 0U };
    uint64_t minusThreeXBuffer[4U] = { 0U };
    uint64_t p256_constant[4U] = { 0U };
    uint64_t multBuffer[8U] = { 0U };
    uint64_t r;
    bool z1;
    Hacl_Impl_LowLevel_shift_256_impl(x, multBuffer);
    Hacl_Impl_SolinasReduction_solinas_reduction_impl(multBuffer, xToDomainBuffer);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(xToDomainBuffer,
      xToDomainBuffer,
      xBuffer);
    Hacl_Impl_P256_MontgomeryMultiplication_montgomery_multiplication_buffer(xBuffer,
      xToDomainBuffer,
      xBuffer);
    Hacl_Impl_P256_Arithmetics_multByThree(xToDomainBuffer, minusThreeXBuffer);
    Hacl_Impl_P256_LowLevel_p256_sub(xBuffer, minusThreeXBuffer, xBuffer);
    p256_constant[0U] = (uint64_t)15608596021259845087U;
    p256_constant[1U] = (uint64_t)12461466548982526096U;
    p256_constant[2U] = (uint64_t)16546823903870267094U;
    p256_constant[3U] = (uint64_t)15866188208926050356U;
    Hacl_Impl_P256_LowLevel_p256_add(xBuffer, p256_constant, xBuffer);
    r = Hacl_Impl_LowLevel_compare_felem(y2Buffer, xBuffer);
    z1 = !(r == (uint64_t)0U);
    return z1;
  }
}

