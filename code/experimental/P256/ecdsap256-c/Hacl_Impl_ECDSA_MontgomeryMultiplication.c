/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: /home/nkulatov/new2/kremlin/kremlin/krml -fbuiltin-uint128 -fnocompound-literals -fc89-scope -fparentheses -fcurly-braces -funroll-loops 4 -warn-error +9 -add-include "kremlib.h" -add-include "FStar_UInt_8_16_32_64.h" /dist/minimal/testlib.c -skip-compilation -no-prefix Hacl.Impl.P256 -bundle Lib.* -bundle Spec.* -bundle C=C.Endianness -bundle Hacl.Hash.SHA2=Hacl.Hash.*,Spec.Hash.* -bundle Hacl.Impl.P256=Hacl.Impl.P256,Hacl.Impl.P256.MontgomeryMultiplication,Hacl.Impl.P256.LowLevel,Hacl.Impl.LowLevel,Hacl.Impl.SolinasReduction,Hacl.Spec.P256.*,Hacl.Spec.Curve25519.*,Hacl.Impl.Curve25519.* -bundle Hacl.Impl.ECDSA.P256SHA256.Verification=Hacl.Impl.MontgomeryMultiplication,Hacl.Impl.ECDSA.P256SHA256.Verification,Hacl.Impl.MM.Exponent -library C,FStar -drop LowStar,Spec,Prims,Lib,C.Loops.*,Hacl.Spec.P256.Lemmas,Hacl.Spec.P256,Hacl.Spec.ECDSA -add-include "c/Lib_PrintBuffer.h" -add-include "FStar_UInt_8_16_32_64.h" -tmpdir ecdsap256-c .output/prims.krml .output/FStar_Pervasives_Native.krml .output/FStar_Pervasives.krml .output/FStar_Squash.krml .output/FStar_Classical.krml .output/FStar_StrongExcludedMiddle.krml .output/FStar_FunctionalExtensionality.krml .output/FStar_List_Tot_Base.krml .output/FStar_List_Tot_Properties.krml .output/FStar_List_Tot.krml .output/FStar_Mul.krml .output/FStar_Math_Lib.krml .output/FStar_Math_Lemmas.krml .output/FStar_Seq_Base.krml .output/FStar_Seq_Properties.krml .output/FStar_Seq.krml .output/FStar_Set.krml .output/FStar_Preorder.krml .output/FStar_Ghost.krml .output/FStar_ErasedLogic.krml .output/FStar_PropositionalExtensionality.krml .output/FStar_PredicateExtensionality.krml .output/FStar_TSet.krml .output/FStar_Monotonic_Heap.krml .output/FStar_Heap.krml .output/FStar_Map.krml .output/FStar_Monotonic_Witnessed.krml .output/FStar_Monotonic_HyperHeap.krml .output/FStar_Monotonic_HyperStack.krml .output/FStar_HyperStack.krml .output/FStar_HyperStack_ST.krml .output/FStar_Calc.krml .output/FStar_BitVector.krml .output/FStar_UInt.krml .output/FStar_UInt32.krml .output/FStar_Universe.krml .output/FStar_GSet.krml .output/FStar_ModifiesGen.krml .output/FStar_Range.krml .output/FStar_Reflection_Types.krml .output/FStar_Tactics_Types.krml .output/FStar_Tactics_Result.krml .output/FStar_Tactics_Effect.krml .output/FStar_Tactics_Util.krml .output/FStar_Reflection_Data.krml .output/FStar_Reflection_Const.krml .output/FStar_Char.krml .output/FStar_Exn.krml .output/FStar_ST.krml .output/FStar_All.krml .output/FStar_List.krml .output/FStar_String.krml .output/FStar_Order.krml .output/FStar_Reflection_Basic.krml .output/FStar_Reflection_Derived.krml .output/FStar_Tactics_Builtins.krml .output/FStar_Reflection_Formula.krml .output/FStar_Reflection_Derived_Lemmas.krml .output/FStar_Reflection.krml .output/FStar_Tactics_Derived.krml .output/FStar_Tactics_Logic.krml .output/FStar_Tactics.krml .output/FStar_BigOps.krml .output/LowStar_Monotonic_Buffer.krml .output/LowStar_Buffer.krml .output/LowStar_BufferOps.krml .output/Spec_Loops.krml .output/FStar_UInt64.krml .output/C_Loops.krml .output/FStar_Int.krml .output/FStar_Int64.krml .output/FStar_Int63.krml .output/FStar_Int32.krml .output/FStar_Int16.krml .output/FStar_Int8.krml .output/FStar_UInt63.krml .output/FStar_UInt16.krml .output/FStar_UInt8.krml .output/FStar_Int_Cast.krml .output/FStar_UInt128.krml .output/FStar_Int_Cast_Full.krml .output/FStar_Int128.krml .output/Lib_IntTypes.krml .output/Lib_Loops.krml .output/Lib_LoopCombinators.krml .output/Lib_RawIntTypes.krml .output/Lib_Sequence.krml .output/Lib_ByteSequence.krml .output/LowStar_ImmutableBuffer.krml .output/Lib_Buffer.krml .output/FStar_HyperStack_All.krml .output/Hacl_Spec_ECDSAP256_Definition.krml .output/Lib_IntTypes_Compatibility.krml .output/Spec_Hash_Definitions.krml .output/Spec_Hash_Lemmas0.krml .output/Spec_Hash_PadFinish.krml .output/Spec_SHA1.krml .output/Spec_MD5.krml .output/Spec_SHA2_Constants.krml .output/Spec_SHA2.krml .output/Spec_Hash.krml .output/Spec_Curve25519_Lemmas.krml .output/FStar_Reflection_Arith.krml .output/FStar_Tactics_Canon.krml .output/Hacl_Spec_P256_Definitions.krml .output/Hacl_Impl_Curve25519_Lemmas.krml .output/Spec_Curve25519.krml .output/Hacl_Spec_Curve25519_Field64_Definition.krml .output/Hacl_Spec_Curve25519_Field64_Lemmas.krml .output/Hacl_Spec_P256_Basic.krml .output/Hacl_Spec_P256_Lemmas.krml .output/Hacl_Spec_P256_Core.krml .output/Hacl_Spec_P256.krml .output/Hacl_Spec_ECDSA.krml .output/Hacl_Impl_LowLevel.krml .output/Hacl_Spec_P256_MontgomeryMultiplication.krml .output/Hacl_Impl_P256_LowLevel.krml .output/Hacl_Spec_P256_SolinasReduction.krml .output/Hacl_Impl_SolinasReduction.krml .output/FStar_Kremlin_Endianness.krml .output/C_Endianness.krml .output/C.krml .output/Lib_ByteBuffer.krml .output/Spec_Hash_Incremental.krml .output/Spec_Hash_Lemmas.krml .output/Hacl_Hash_Lemmas.krml .output/LowStar_Modifies.krml .output/Hacl_Hash_Definitions.krml .output/Hacl_Hash_PadFinish.krml .output/Hacl_Hash_MD.krml .output/Hacl_Impl_ECDSA_MontgomeryMultiplication.krml .output/Hacl_Spec_P256_MontgomeryMultiplication_PointDouble.krml .output/Hacl_Spec_P256_MontgomeryMultiplication_PointAdd.krml .output/Hacl_Spec_P256_Ladder.krml .output/Hacl_Impl_ECDSA_MM_Exponent.krml .output/Hacl_Hash_Core_SHA2_Constants.krml .output/Hacl_Hash_Core_SHA2.krml .output/Hacl_Impl_P256_MontgomeryMultiplication.krml .output/Hacl_Spec_P256_Normalisation.krml .output/Hacl_Impl_P256.krml .output/Hacl_Hash_SHA2.krml .output/Hacl_Impl_ECDSA_P256SHA256_Verification.krml
  F* version: ea91ae8c
  KreMLin version: 27ce15c8
 */

#include "Hacl_Impl_ECDSA_MontgomeryMultiplication.h"

uint64_t
Hacl_Impl_ECDSA_MontgomeryMultiplication_prime256order_buffer[4U] =
  {
    (uint64_t)17562291160714782033U,
    (uint64_t)13611842547513532036U,
    (uint64_t)18446744073709551615U,
    (uint64_t)18446744069414584320U
  };

typedef struct
K___uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
  uint64_t thd;
  uint64_t f3;
  uint64_t f4;
  uint64_t f5;
  uint64_t f6;
  uint64_t f7;
  uint64_t f8;
}
K___uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t;

static void
Hacl_Impl_ECDSA_MontgomeryMultiplication_add8_without_carry1(
  uint64_t *t,
  uint64_t *r,
  uint64_t *result
)
{
  uint64_t t0 = t[0U];
  uint64_t t1 = t[1U];
  uint64_t t2 = t[2U];
  uint64_t t3 = t[3U];
  uint64_t t4 = t[4U];
  uint64_t t5 = t[5U];
  uint64_t t6 = t[6U];
  uint64_t t7 = t[7U];
  uint64_t r0 = r[0U];
  uint64_t r1 = r[1U];
  uint64_t r2 = r[2U];
  uint64_t r3 = r[3U];
  uint64_t r4 = r[4U];
  uint64_t r5 = r[5U];
  uint64_t r6 = r[6U];
  uint64_t r7 = r[7U];
  K___uint64_t_uint64_t scrut0 = Hacl_Spec_P256_Basic_addcarry(t0, r0, (uint64_t)0U);
  uint64_t o00 = scrut0.fst;
  uint64_t c0 = scrut0.snd;
  K___uint64_t_uint64_t scrut1 = Hacl_Spec_P256_Basic_addcarry(t1, r1, c0);
  uint64_t o10 = scrut1.fst;
  uint64_t c1 = scrut1.snd;
  K___uint64_t_uint64_t scrut2 = Hacl_Spec_P256_Basic_addcarry(t2, r2, c1);
  uint64_t o20 = scrut2.fst;
  uint64_t c2 = scrut2.snd;
  K___uint64_t_uint64_t scrut3 = Hacl_Spec_P256_Basic_addcarry(t3, r3, c2);
  uint64_t o30 = scrut3.fst;
  uint64_t c30 = scrut3.snd;
  K___uint64_t_K___uint64_t_uint64_t_uint64_t_uint64_t lit0;
  K___uint64_t_K___uint64_t_uint64_t_uint64_t_uint64_t scrut4;
  uint64_t o3;
  uint64_t o2;
  uint64_t o1;
  uint64_t o0;
  uint64_t c3;
  K___uint64_t_uint64_t scrut5;
  uint64_t o4;
  uint64_t c4;
  K___uint64_t_uint64_t scrut6;
  uint64_t o5;
  uint64_t c5;
  K___uint64_t_uint64_t scrut7;
  uint64_t o6;
  uint64_t c6;
  K___uint64_t_uint64_t scrut8;
  uint64_t o7;
  uint64_t c7;
  lit0.fst = c30;
  lit0.snd.fst = o00;
  lit0.snd.snd = o10;
  lit0.snd.thd = o20;
  lit0.snd.f3 = o30;
  scrut4 = lit0;
  o3 = scrut4.snd.f3;
  o2 = scrut4.snd.thd;
  o1 = scrut4.snd.snd;
  o0 = scrut4.snd.fst;
  c3 = scrut4.fst;
  scrut5 = Hacl_Spec_P256_Basic_addcarry(t4, r4, c3);
  o4 = scrut5.fst;
  c4 = scrut5.snd;
  scrut6 = Hacl_Spec_P256_Basic_addcarry(t5, r5, c4);
  o5 = scrut6.fst;
  c5 = scrut6.snd;
  scrut7 = Hacl_Spec_P256_Basic_addcarry(t6, r6, c5);
  o6 = scrut7.fst;
  c6 = scrut7.snd;
  scrut8 = Hacl_Spec_P256_Basic_addcarry(t7, r7, c6);
  o7 = scrut8.fst;
  c7 = scrut8.snd;
  {
    K___uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t lit1;
    K___uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t scrut9;
    uint64_t r010;
    uint64_t r110;
    uint64_t r210;
    uint64_t r310;
    uint64_t r410;
    uint64_t r510;
    uint64_t r610;
    uint64_t r710;
    lit1.fst = c7;
    lit1.snd = o0;
    lit1.thd = o1;
    lit1.f3 = o2;
    lit1.f4 = o3;
    lit1.f5 = o4;
    lit1.f6 = o5;
    lit1.f7 = o6;
    lit1.f8 = o7;
    scrut9 = lit1;
    r010 = scrut9.snd;
    r110 = scrut9.thd;
    r210 = scrut9.f3;
    r310 = scrut9.f4;
    r410 = scrut9.f5;
    r510 = scrut9.f6;
    r610 = scrut9.f7;
    r710 = scrut9.f8;
    {
      K___uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t lit;
      K___uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t_uint64_t scrut;
      uint64_t r01;
      uint64_t r11;
      uint64_t r21;
      uint64_t r31;
      uint64_t r41;
      uint64_t r51;
      uint64_t r61;
      uint64_t r71;
      lit.fst = r010;
      lit.snd = r110;
      lit.thd = r210;
      lit.f3 = r310;
      lit.f4 = r410;
      lit.f5 = r510;
      lit.f6 = r610;
      lit.f7 = r710;
      scrut = lit;
      r01 = scrut.fst;
      r11 = scrut.snd;
      r21 = scrut.thd;
      r31 = scrut.f3;
      r41 = scrut.f4;
      r51 = scrut.f5;
      r61 = scrut.f6;
      r71 = scrut.f7;
      result[0U] = r01;
      result[1U] = r11;
      result[2U] = r21;
      result[3U] = r31;
      result[4U] = r41;
      result[5U] = r51;
      result[6U] = r61;
      result[7U] = r71;
    }
  }
}

static void
Hacl_Impl_ECDSA_MontgomeryMultiplication_montgomery_multiplication_round(
  uint64_t *t,
  uint64_t *round,
  uint64_t k0
)
{
  uint64_t yBuffer[8U] = { 0U };
  uint64_t t2[8U] = { 0U };
  uint64_t t3[8U] = { 0U };
  uint64_t t1 = t[0U];
  uint128_t res = (uint128_t)t1 * k0;
  K___uint64_t_uint64_t scrut;
  uint64_t y;
  scrut.fst = (uint64_t)res;
  scrut.snd = (uint64_t)(res >> (uint32_t)64U);
  y = scrut.fst;
  Hacl_Impl_LowLevel_shortened_mul(Hacl_Impl_ECDSA_MontgomeryMultiplication_prime256order_buffer,
    y,
    t2);
  Hacl_Impl_ECDSA_MontgomeryMultiplication_add8_without_carry1(t, t2, t3);
  Hacl_Impl_LowLevel_shift8(t3, round);
}

void
Hacl_Impl_ECDSA_MontgomeryMultiplication_reduction_prime_2prime_order(
  uint64_t *x,
  uint64_t *result
)
{
  uint64_t tempBuffer[4U] = { 0U };
  uint64_t
  c =
    Hacl_Impl_LowLevel_sub4_il(x,
      Hacl_Impl_ECDSA_MontgomeryMultiplication_prime256order_buffer,
      tempBuffer);
  Hacl_Impl_LowLevel_cmovznz4(c, tempBuffer, x, result);
}

static uint64_t Hacl_Impl_ECDSA_MontgomeryMultiplication_upload_k0()
{
  return (uint64_t)14758798090332847183U;
}

void
Hacl_Impl_ECDSA_MontgomeryMultiplication_montgomery_multiplication_ecdsa_module(
  uint64_t *a,
  uint64_t *b,
  uint64_t *result
)
{
  uint64_t t[8U] = { 0U };
  uint64_t round2[8U] = { 0U };
  uint64_t round4[8U] = { 0U };
  uint64_t prime_p256_orderBuffer[4U] = { 0U };
  uint64_t k0 = Hacl_Impl_ECDSA_MontgomeryMultiplication_upload_k0();
  Hacl_Impl_LowLevel_mul(a, b, t);
  {
    uint64_t tempRound[8U] = { 0U };
    Hacl_Impl_ECDSA_MontgomeryMultiplication_montgomery_multiplication_round(t, tempRound, k0);
    Hacl_Impl_ECDSA_MontgomeryMultiplication_montgomery_multiplication_round(tempRound,
      round2,
      k0);
    {
      uint64_t tempRound0[8U] = { 0U };
      Hacl_Impl_ECDSA_MontgomeryMultiplication_montgomery_multiplication_round(round2,
        tempRound0,
        k0);
      Hacl_Impl_ECDSA_MontgomeryMultiplication_montgomery_multiplication_round(tempRound0,
        round4,
        k0);
      {
        uint64_t tempBuffer[4U] = { 0U };
        uint64_t tempBufferForSubborrow = (uint64_t)0U;
        uint64_t cin = round4[4U];
        uint64_t *x = round4;
        uint64_t
        c =
          Hacl_Impl_LowLevel_sub4_il(x,
            Hacl_Impl_ECDSA_MontgomeryMultiplication_prime256order_buffer,
            tempBuffer);
        uint64_t
        carry = Hacl_Impl_LowLevel_sub_borrow(c, cin, (uint64_t)0U, &tempBufferForSubborrow);
        Hacl_Impl_LowLevel_cmovznz4(carry, tempBuffer, x, result);
      }
    }
  }
}

